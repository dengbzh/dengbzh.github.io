<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Mark&#39;s Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://dengbzh.github.io/img/post-bg-unix-linux.jpg">
    <meta property="twitter:image" content="https://dengbzh.github.io/img/post-bg-unix-linux.jpg" />
    

    
    <meta name="title" content="golang包分析 - sync.Pool" />
    <meta property="og:title" content="golang包分析 - sync.Pool" />
    <meta property="twitter:title" content="golang包分析 - sync.Pool" />
    

    
    <meta name="description" content="Mark，中台程序员, 云原生爱好者，猫奴, 周末厨子 | 这里是 Mark 的博客，Stay Hungry Stay Foolish。">
    <meta property="og:description" content="Mark，中台程序员, 云原生爱好者，猫奴, 周末厨子 | 这里是 Mark 的博客，Stay Hungry Stay Foolish。" />
    <meta property="twitter:description" content="Mark，中台程序员, 云原生爱好者，猫奴, 周末厨子 | 这里是 Mark 的博客，Stay Hungry Stay Foolish。" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="Mark, 中台, 高并发, 分布式,  Blog, 博客, 个人网站, 互联网, Web, 云原生, PaaS, Istio, Kubernetes, 微服务, Microservice">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>golang包分析 - sync.Pool-Mark的博客 | Mark&#39;s Blog</title>

    <link rel="canonical" href="/2020/05/14/golang/sync-Pool/">

    <link rel="stylesheet" href="/css/iDisqus.min.css"/>
	
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">
    
    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    
    

    
    
    <script src="/js/jquery.min.js"></script>
    
    
    <script src="/js/bootstrap.min.js"></script>
    
    
    <script src="/js/hux-blog.min.js"></script>

    
    

</head>



<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Mark&#39;s Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/golang">golang</a>
                        </li>
                        
                    
                    
		    

                    
		    <li>
                        <a href="/search">SEARCH <img src="/img/search.png" height="15" style="cursor: pointer;" alt="Search"></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/post-bg-unix-linux.jpg')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/sync.pool" title="sync.Pool">
                            sync.Pool
                        </a>
                        
                        <a class="tag" href="/tags/golang" title="golang">
                            golang
                        </a>
                        
                    </div>
                    <h1>golang包分析 - sync.Pool</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by 
                        
                                 &#34;Mark&#34;
                         
                        on 
                        Thursday, May 14, 2020
                        
                        
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-11 col-lg-offset-1
                col-md-10 col-md-offset-1
                post-container">

                
                <header>
                    <h2>TOC</h2>
                </header>
                <nav id="TableOfContents">
  <ul>
    <li><a href="#使用场景">使用场景</a></li>
    <li><a href="#实验测试">实验测试</a>
      <ul>
        <li><a href="#实现设计">实现设计</a></li>
        <li><a href="#原理代码分析">原理&amp;代码分析</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#refrence">Refrence</a></li>
  </ul>
</nav>
                
                <blockquote>
<p>在工程实践中，我们经常会使用临时对象来缓存数据，当这些调用变得频繁以后，就会出现性能问题，一般会表现为，平均响应时间变短。长尾增多。并随着压力增加会不断恶化，通常针对这类场景，我们会研发一个临时对象缓存来减少系统的内存分配以及GC从而提升程序整体性能。针对此类场景golang也在go1.3版本推出了官方包用作通用解决方案。本文将会从使用场景，实验测试，原理分析，代码分析来解读这一工具。本文基于go1.13</p>
</blockquote>
<h1 id="使用场景">使用场景</h1>
<p>根据<code>sync.Pool</code>的官方介绍<a href="#refer-go-org-pkg-sync"><!-- raw HTML omitted -->[1]<!-- raw HTML omitted --></a>。</p>
<ul>
<li>
<p><code>sync.Pool</code>是一个用于存储临时对象的工具，缓存在<code>sync.Pool</code>中的对象会被系统回收，并且不会告知使用方，如果这个对象仅仅在Pool中被引用的话，则会被GC。</p>
</li>
<li>
<p>同一个Pool可以在多个go携程中并发使用。</p>
</li>
</ul>
<h1 id="实验测试">实验测试</h1>
<p>通过官方的描述，我们可以知道<code>sync.Pool</code>是用于存放临时对象，并且是thread-safe的。通过重用临时对象达到减少GC提升程序性能的目的。</p>
<h2 id="实现设计">实现设计</h2>
<h3 id="实验指标">实验指标</h3>
<p>直观上来说，我们可以通过不断使用临时变量的方式对比测试其开销。预期的现象是，使用<code>sync.Pool</code>的程序应该耗时比较低，并且为了证明耗时是由GC引入的，我们可以统计实验过程中gc次数来印证。因此实现指标应为：</p>
<ul>
<li>耗时</li>
<li>GC次数</li>
</ul>
<h3 id="开始实验">开始实验</h3>
<h4 id="实验一不用syncpool">实验一、不用sync.Pool</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ff79c6">package</span> main

<span style="color:#ff79c6">import</span> (
    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
    <span style="color:#f1fa8c">&#34;time&#34;</span>
    <span style="color:#f1fa8c">&#34;os&#34;</span>
    <span style="color:#f1fa8c">&#34;runtime/trace&#34;</span>
)

<span style="color:#8be9fd;font-style:italic">const</span> (
    outter_loop = <span style="color:#bd93f9">1000000</span>
    inner_loop = <span style="color:#bd93f9">2000</span>
)

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">genMsg</span>(n <span style="color:#8be9fd">int</span>) []<span style="color:#8be9fd">byte</span> {
    msg <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, <span style="color:#bd93f9">10240</span>)
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> msg {
        msg[i] = <span style="color:#8be9fd;font-style:italic">byte</span>(n)
    }
    <span style="color:#ff79c6">return</span> msg
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">doSomeWork</span>(buffer []<span style="color:#8be9fd">byte</span>) (elapsed time.Duration) {
    start <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
    <span style="color:#ff79c6">for</span> i<span style="color:#ff79c6">:=</span><span style="color:#bd93f9">0</span>; i&lt;inner_loop; i<span style="color:#ff79c6">++</span> {
        <span style="color:#6272a4">// do some work
</span><span style="color:#6272a4"></span>    }
    <span style="color:#ff79c6">return</span> time.<span style="color:#50fa7b">Since</span>(start)
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
    f, _ <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Create</span>(<span style="color:#f1fa8c">&#34;trace_withoutPool.out&#34;</span>)
    <span style="color:#ff79c6">defer</span> f.<span style="color:#50fa7b">Close</span>()
    trace.<span style="color:#50fa7b">Start</span>(f)
    <span style="color:#ff79c6">defer</span> trace.<span style="color:#50fa7b">Stop</span>()
    <span style="color:#8be9fd;font-style:italic">var</span> worst time.Duration
    <span style="color:#ff79c6">for</span> i<span style="color:#ff79c6">:=</span><span style="color:#bd93f9">0</span>; i&lt;outter_loop; i<span style="color:#ff79c6">++</span> {
        msg <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">genMsg</span>(i)
        elapsed <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">doSomeWork</span>(msg)
        <span style="color:#ff79c6">if</span> elapsed &gt; worst {
            worst = elapsed
        }
    }
    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Worst time: &#34;</span>, worst)
}
</code></pre></div><!-- raw HTML omitted -->
<h4 id="实验二使用syncpool">实验二、使用sync.Pool</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#ff79c6">package</span> main

<span style="color:#ff79c6">import</span> (
    <span style="color:#f1fa8c">&#34;fmt&#34;</span>
    <span style="color:#f1fa8c">&#34;time&#34;</span>
    <span style="color:#f1fa8c">&#34;sync&#34;</span>
    <span style="color:#f1fa8c">&#34;os&#34;</span>
    <span style="color:#f1fa8c">&#34;runtime/trace&#34;</span>
)

<span style="color:#8be9fd;font-style:italic">const</span> (
    outter_loop = <span style="color:#bd93f9">999999</span>
    inner_loop = <span style="color:#bd93f9">2000</span>
)

<span style="color:#8be9fd;font-style:italic">var</span> msgPool = sync.Pool{
    New: <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{} {
        <span style="color:#ff79c6">return</span> <span style="color:#8be9fd;font-style:italic">make</span>([]<span style="color:#8be9fd">byte</span>, <span style="color:#bd93f9">10240</span>)
    },
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">genMsg</span>(n <span style="color:#8be9fd">int</span>) []<span style="color:#8be9fd">byte</span> {
    msg <span style="color:#ff79c6">:=</span> msgPool.<span style="color:#50fa7b">Get</span>().([]<span style="color:#8be9fd">byte</span>)
    <span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> msg {
        msg[i] = <span style="color:#8be9fd;font-style:italic">byte</span>(n)
    }
    <span style="color:#ff79c6">return</span> msg
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">doSomeWork</span>(buffer []<span style="color:#8be9fd">byte</span>) (elapsed time.Duration) {
    start <span style="color:#ff79c6">:=</span> time.<span style="color:#50fa7b">Now</span>()
    <span style="color:#ff79c6">for</span> i<span style="color:#ff79c6">:=</span><span style="color:#bd93f9">0</span>; i&lt;inner_loop; i<span style="color:#ff79c6">++</span> {
        <span style="color:#6272a4">// do some work
</span><span style="color:#6272a4"></span>    }
    msgPool.<span style="color:#50fa7b">Put</span>(buffer)
    <span style="color:#ff79c6">return</span> time.<span style="color:#50fa7b">Since</span>(start)
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">main</span>() {
    f, _ <span style="color:#ff79c6">:=</span> os.<span style="color:#50fa7b">Create</span>(<span style="color:#f1fa8c">&#34;trace_withPool.out&#34;</span>)
    <span style="color:#ff79c6">defer</span> f.<span style="color:#50fa7b">Close</span>()
    trace.<span style="color:#50fa7b">Start</span>(f)
    <span style="color:#ff79c6">defer</span> trace.<span style="color:#50fa7b">Stop</span>()
    <span style="color:#8be9fd;font-style:italic">var</span> worst time.Duration
    <span style="color:#ff79c6">for</span> i<span style="color:#ff79c6">:=</span><span style="color:#bd93f9">0</span>; i&lt;outter_loop; i<span style="color:#ff79c6">++</span> {
        msg <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">genMsg</span>(i)
        elapsed <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">doSomeWork</span>(msg)
        <span style="color:#ff79c6">if</span> elapsed &gt; worst {
            worst = elapsed
        }
    }
    fmt.<span style="color:#50fa7b">Println</span>(<span style="color:#f1fa8c">&#34;Worst time: &#34;</span>, worst)
}
</code></pre></div><h3 id="实验结论">实验结论</h3>
<p>没有使用Pool的情况</p>
<p><img src="/img/sync-pool/without_Pool.png" alt="不使用sync_pool实验结论"></p>
<p>Worst time: 635.826µs</p>
<p>使用了Pool情况
<img src="/img/sync-pool/with_Pool.png" alt="使用sync_pool实验结论"></p>
<p>Worst time: 285.427µs</p>
<p>通过实验，我们可以看到程序耗时、长尾、gc时间在使用sync.Pool以后都减少了。因此使用sync.Pool是大有裨益的。</p>
<h2 id="原理代码分析">原理&amp;代码分析</h2>
<p><code>sync.Pool</code>包含Get和Put两个方法。其中Put方法会将临时对象放入缓存中。Get方法将从缓存中取出临时对象。当没有临时对象的时候，将会通过New方法生成一个临时对象。函数签名如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go">
<span style="color:#8be9fd;font-style:italic">type</span> Pool <span style="color:#8be9fd;font-style:italic">struct</span> {

    <span style="color:#6272a4">// New optionally specifies a function to generate
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// a value when Get would otherwise return nil.
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// It may not be changed concurrently with calls to Get.
</span><span style="color:#6272a4"></span>    New <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{}
    <span style="color:#6272a4">// contains filtered or unexported fields
</span><span style="color:#6272a4"></span>}

<span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">Get</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{}

<span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">Put</span>(x <span style="color:#8be9fd;font-style:italic">interface</span>{})

</code></pre></div><p>从函数签名我们也可以看出在创建一个Pool时候，我们需要提供一个New方法。这就是Pool创建临时对象的方法。那么Pool是如何存储和管理这些对象呢？</p>
<h3 id="pool的存储结构">Pool的存储结构</h3>
<p>下图简单描绘了Pool的整体结构，其中简化了一些结构。但是不影响对其存储的分析：
<img src="/img/sync-pool/sync-arch-simple.png" alt="Pool的存储结构"></p>
<p>Pool通过<code>[]*allPools</code>和<code>[]*oldPools</code>来引用程序中所有的Pool并且对其进行生命周期管理。管理策略后面介绍。<code>allPools</code>中会引用到我们创建的Pool(如<a href="#refer-experiment-2">实验二</a>中的msgPool)</p>
<h3 id="pool基本数据结构">Pool基本数据结构</h3>
<p>Pool<a href="#refer-go-org-pkg-sync-src"><!-- raw HTML omitted -->[2]<!-- raw HTML omitted --></a>包含了local, localSize, victim, victimSize, New。分别如下含义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">type</span> Pool <span style="color:#8be9fd;font-style:italic">struct</span> {
	noCopy noCopy<span style="color:#6272a4">//禁止被复制，也就是说是全局唯一的。
</span><span style="color:#6272a4"></span>
	local     unsafe.Pointer <span style="color:#6272a4">// 本地缓存，长度和P数量一致，指向实际类型为poolLocal的slice，每一个slice表示当前P对应的缓存
</span><span style="color:#6272a4"></span>	localSize <span style="color:#8be9fd">uintptr</span>        <span style="color:#6272a4">// 表示的是当前缓存的大小（可以理解为最大偏移量）
</span><span style="color:#6272a4"></span>
	victim     unsafe.Pointer <span style="color:#6272a4">// 上一个GC周期的local对象
</span><span style="color:#6272a4"></span>	victimSize <span style="color:#8be9fd">uintptr</span>        <span style="color:#6272a4">// 上一个GC周期的local对象的缓存大小
</span><span style="color:#6272a4"></span>
	<span style="color:#6272a4">//当调用Get方法的返回值是nil，会调用该方法，生成对象。这个方法在调用Get的时候是不能改变的。
</span><span style="color:#6272a4"></span>	New <span style="color:#8be9fd;font-style:italic">func</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{}
}



<span style="color:#8be9fd;font-style:italic">type</span> poolLocalInternal <span style="color:#8be9fd;font-style:italic">struct</span> {
	private <span style="color:#8be9fd;font-style:italic">interface</span>{} <span style="color:#6272a4">// 每一个P都存在一个私有对象
</span><span style="color:#6272a4"></span>	shared  poolChain   <span style="color:#6272a4">// 每一个P都会存在一个共享对象，Local P 可以 pushHead/popHead; 其他P P 可以 popTail.
</span><span style="color:#6272a4"></span>}

<span style="color:#6272a4">// Pool.local真正引用的对象
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">type</span> poolLocal <span style="color:#8be9fd;font-style:italic">struct</span> {
	poolLocalInternal

	<span style="color:#6272a4">// pad保证pollLocal对象占用的都是cache line大小(128)的整数倍。
</span><span style="color:#6272a4"></span>	pad [<span style="color:#bd93f9">128</span> <span style="color:#ff79c6">-</span> unsafe.<span style="color:#50fa7b">Sizeof</span>(poolLocalInternal{})<span style="color:#ff79c6">%</span><span style="color:#bd93f9">128</span>]<span style="color:#8be9fd">byte</span>
}

</code></pre></div><ul>
<li>Pool 内嵌一个noCopy使得每一个对象都是全局唯一的</li>
<li>Pool中的local表示当前的P（参考goroutine调度<a href="#refer-understaning-goroutine"><!-- raw HTML omitted -->[6]<!-- raw HTML omitted --></a>）使用的缓存，因此local是一个长度为runtime.GOMAXPROCS[0]大小的数组。数组中的对象为poolLocalInternal的指针</li>
<li>poolLocalInternal包含private和shared对象，private对象是本地P访问的，如果本地private对象为nil，则可以去其他P”偷”取shared对象。没有成功则会尝试用victim字段进行获取</li>
<li>shared对象是poolChain类型的一个双向链表，该链表是基于无锁队列进行封装。</li>
<li>poolLocal就是对poolLocalInternal的padding。poolLocal占满整个缓存防止false sharing<a href="#refer-false-sharing"><!-- raw HTML omitted -->[4]<!-- raw HTML omitted --></a></li>
</ul>
<h3 id="pool执行流程">Pool执行流程</h3>
<p>Pool的整体数据结构如上，由于Pool只存在连个方法，<code>Get</code>和<code>Put</code>，因此，可以从这两个方法入手研究Pool的执行流程。</p>
<p><code>Get</code>流程（为了整个过程清晰删除部分race相关代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">Get</span>() <span style="color:#8be9fd;font-style:italic">interface</span>{} {
	<span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>	l, pid <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">pin</span>()
	x <span style="color:#ff79c6">:=</span> l.private
	l.private = <span style="color:#ff79c6">nil</span>
	<span style="color:#ff79c6">if</span> x <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
		<span style="color:#6272a4">// Try to pop the head of the local shard. We prefer
</span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// the head over the tail for temporal locality of
</span><span style="color:#6272a4"></span>		<span style="color:#6272a4">// reuse.
</span><span style="color:#6272a4"></span>		x, _ = l.shared.<span style="color:#50fa7b">popHead</span>()
		<span style="color:#ff79c6">if</span> x <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
			x = p.<span style="color:#50fa7b">getSlow</span>(pid)
		}
    }
    <span style="color:#6272a4">//解除非抢占
</span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">runtime_procUnpin</span>()
	<span style="color:#6272a4">//...
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> x <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> <span style="color:#ff79c6">&amp;&amp;</span> p.New <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
		x = p.<span style="color:#50fa7b">New</span>()
	}
	<span style="color:#ff79c6">return</span> x
}

</code></pre></div><p><code>Get</code>方法的整体流程还是比较清晰的：</p>
<p>1、先通过<code>p.pin()</code>方法拿到当前P对应的<code>poolLocal</code>对象和pid</p>
<p>2、从<code>poolLocal</code>中获取<code>private</code>对象，如果<code>private</code>对象为<code>nil</code>，则从<code>shared</code>对象中取出，如果<code>shared</code>里面没有，则从其他P的<code>shared</code>对象中『偷』(steal)</p>
<p>3、通过<code>runtime_procPin</code>解除非抢占。（这是由于在前面几行中会执行<code>runtime_procPin</code>，用于排除抢占。也就是说从这个P上面获取<code>poolLocal</code>对象是并发安全的）</p>
<p>4、如果最后还是没有缓存对象，则使用<code>p.New()</code>方法创建一个对象返回。这里我们可以看到没有对<code>New()</code>的执行进行同步控制，所以运行时更改New方法不是并发安全的</p>
<p>这里需要特别说明的是，每一个<code>poolLocal</code>对象都对应了一个P，这样做的好处是，不同P在使用<code>Pool</code>的<code>private</code>数据时候，不需要加锁，因为不同P之间的<code>private</code>数据没有争用。同一个P由于禁止抢占，也不会有争用问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">pin</span>() (<span style="color:#ff79c6">*</span>poolLocal, <span style="color:#8be9fd">int</span>) {
    <span style="color:#6272a4">// 禁止抢占
</span><span style="color:#6272a4"></span>	pid <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runtime_procPin</span>()
    <span style="color:#6272a4">// 获取local队列长度
</span><span style="color:#6272a4"></span>	s <span style="color:#ff79c6">:=</span> atomic.<span style="color:#50fa7b">LoadUintptr</span>(<span style="color:#ff79c6">&amp;</span>p.localSize) <span style="color:#6272a4">// load-acquire
</span><span style="color:#6272a4"></span>	l <span style="color:#ff79c6">:=</span> p.local                          <span style="color:#6272a4">// load-consume
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(pid) &lt; s { <span style="color:#6272a4">// 如果pid小于队列长度，则代表已经进行初始化，可以直接返回
</span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> <span style="color:#50fa7b">indexLocal</span>(l, pid), pid
    }
    <span style="color:#6272a4">// 否则进行初始化
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">return</span> p.<span style="color:#50fa7b">pinSlow</span>()
}

<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">indexLocal</span>(l unsafe.Pointer, i <span style="color:#8be9fd">int</span>) <span style="color:#ff79c6">*</span>poolLocal {
	lp <span style="color:#ff79c6">:=</span> unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#8be9fd;font-style:italic">uintptr</span>(l) <span style="color:#ff79c6">+</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(i)<span style="color:#ff79c6">*</span>unsafe.<span style="color:#50fa7b">Sizeof</span>(poolLocal{}))
	<span style="color:#ff79c6">return</span> (<span style="color:#ff79c6">*</span>poolLocal)(lp)
}

<span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">pinSlow</span>() (<span style="color:#ff79c6">*</span>poolLocal, <span style="color:#8be9fd">int</span>) {
    <span style="color:#6272a4">// 这里需要解除非抢占
</span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// 如果不解除，使用allPoolsMu.Lock()加锁被hang住，则整个P都被hang住
</span><span style="color:#6272a4"></span>	<span style="color:#50fa7b">runtime_procUnpin</span>()
	allPoolsMu.<span style="color:#50fa7b">Lock</span>()
    <span style="color:#ff79c6">defer</span> allPoolsMu.<span style="color:#50fa7b">Unlock</span>()
    <span style="color:#6272a4">// 重新开启非抢占
</span><span style="color:#6272a4"></span>	pid <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">runtime_procPin</span>()
	<span style="color:#6272a4">// 由于刚才解除了非抢占，所以需要重新检查一下状态
</span><span style="color:#6272a4"></span>	s <span style="color:#ff79c6">:=</span> p.localSize
	l <span style="color:#ff79c6">:=</span> p.local
	<span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">uintptr</span>(pid) &lt; s {
		<span style="color:#ff79c6">return</span> <span style="color:#50fa7b">indexLocal</span>(l, pid), pid
	}
	<span style="color:#ff79c6">if</span> p.local <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
		allPools = <span style="color:#8be9fd;font-style:italic">append</span>(allPools, p)
	}
	<span style="color:#6272a4">// 如果运行时P数量变化了。这里会重新分配内存
</span><span style="color:#6272a4"></span>	size <span style="color:#ff79c6">:=</span> runtime.<span style="color:#50fa7b">GOMAXPROCS</span>(<span style="color:#bd93f9">0</span>)
	local <span style="color:#ff79c6">:=</span> <span style="color:#8be9fd;font-style:italic">make</span>([]poolLocal, size)
	atomic.<span style="color:#50fa7b">StorePointer</span>(<span style="color:#ff79c6">&amp;</span>p.local, unsafe.<span style="color:#50fa7b">Pointer</span>(<span style="color:#ff79c6">&amp;</span>local[<span style="color:#bd93f9">0</span>])) <span style="color:#6272a4">// store-release
</span><span style="color:#6272a4"></span>	atomic.<span style="color:#50fa7b">StoreUintptr</span>(<span style="color:#ff79c6">&amp;</span>p.localSize, <span style="color:#8be9fd;font-style:italic">uintptr</span>(size))         <span style="color:#6272a4">// store-release
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">&amp;</span>local[pid], pid
}

</code></pre></div><p>上面的代码详细描述了<code>pin()</code>这个方法。</p>
<p>1、使用<code>runtime_procPin</code>禁止抢占，获取<code>localSize</code>和<code>local</code>，如果没有初始化则<code>localSize</code>为<code>nil</code>, 否则应该和p的数量相等</p>
<p>2、如果pid在<code>localSize</code>范围内，则直接根据<code>localSize</code>返回对应的<code>poolLocal</code>对象，这也解释了为什么使用指针来表示<code>local</code>的大小。因为是通过偏移量的方式求的的<code>poolLocal对象</code></p>
<p>3、如果pid不在<code>localSize</code>范围内，则表示没有进行初始化，或者运行时增加了P的数量。此时需要重新分配<code>local</code>内存（<code>pingSlow()</code>)</p>
<p>4、<code>pingSlow()</code>第一步解除非抢占，这一步的目的是防止使用<code>allPoolsMu.Lock()</code>加锁被阻塞，导致整个P被阻塞</p>
<p>5、<code>allPools</code>根据<code>Pool</code>的架构，<code>allPools</code>存储的是全局所有的<code>Pool</code>实例，因此需要进行加锁。这里也可以看出，如果一致没有命中缓存会导致频繁加锁，频繁加锁会导致<code>Pool</code>性能问题</p>
<p>6、获取锁以后，需要重新检查一下状态（因为在强锁过程中，可能有其他P或者G创建了）</p>
<p>7、创建<code>local</code>数组</p>
<p><code>Put</code>流程（为了整个过程清晰删除部分race相关代码）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#6272a4">// Put adds x to the pool.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (p <span style="color:#ff79c6">*</span>Pool) <span style="color:#50fa7b">Put</span>(x <span style="color:#8be9fd;font-style:italic">interface</span>{}) {
	<span style="color:#ff79c6">if</span> x <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
		<span style="color:#ff79c6">return</span>
    }
    <span style="color:#6272a4">//...
</span><span style="color:#6272a4"></span>	l, _ <span style="color:#ff79c6">:=</span> p.<span style="color:#50fa7b">pin</span>()
	<span style="color:#ff79c6">if</span> l.private <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">nil</span> {
		l.private = x
		x = <span style="color:#ff79c6">nil</span>
	}
	<span style="color:#ff79c6">if</span> x <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">nil</span> {
		l.shared.<span style="color:#50fa7b">pushHead</span>(x)
	}
    <span style="color:#50fa7b">runtime_procUnpin</span>()
    <span style="color:#6272a4">// ...
</span><span style="color:#6272a4"></span>}
</code></pre></div><p><code>Put()</code>整个过程比Get要稍微简单一些:</p>
<p>1、通过<code>pin()</code>方法，获取当前的P对应的<code>poolLocal</code>对象。</p>
<p>2、如果<code>private</code>为空，将x放入<code>private</code>字段，否则放入<code>shared</code>字段。</p>
<p>3、解除非抢占</p>
<p>通过上面的分析，可以得到sync.Pool的工作流图<a href="#refer-understaning-Design-of-Sync-Pool"><!-- raw HTML omitted -->[7]<!-- raw HTML omitted --></a></p>
<p><img src="/img/sync-pool/sync-pool-workflow.png" alt="workflow"></p>
<h3 id="pool生命周期">Pool生命周期</h3>
<p>在<code>sync.Pool</code>的官方包中，说明了<code>sync.Pool</code>会在不通知用户的情况下清除这个缓存。这个设计是保证<code>Pool</code>不会无限膨胀，那么这些数据到底是什么时候清除呢？这个涉及GC和<code>sync.Pool</code>的<code>victim</code>设计。 GC的方法这里不赘述，需要特别指出的是，在<code>sync.Pool</code>的<code>init()</code>方法中有这样一个设计：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">init</span>() {
	<span style="color:#50fa7b">runtime_registerPoolCleanup</span>(poolCleanup)
}
<span style="color:#6272a4">// Implemented in runtime.
</span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runtime_registerPoolCleanup</span>(cleanup <span style="color:#8be9fd;font-style:italic">func</span>())
<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runtime_procPin</span>() <span style="color:#8be9fd">int</span>
<span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">runtime_procUnpin</span>()
</code></pre></div><p>在<code>init()</code>方法中，完成了<code>sync.PoolGC</code>的注册。在运行时（准确来说是GC发生时）会执行<code>poolCleanup()</code>这个hook（在STW阶段调用）。（关于<code>runtime_xxx()</code>这种引用方式可以简单说明下，go语言是通过首字母大小写的方式导出的本地方法，不过也有一些hack的方式，比如sync.Pool包中，声明了一个函数符号，在函数实现方可以使用<code>//go:linkname xxx xxx</code>，可将这个符号和实现链接起来，在工程实现上几乎用不到这类case，了解存在这些规则即可）</p>
<p>下面我们可以仔细看下<code>poolCleanup()</code>这个函数。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">poolCleanup</span>() {

	<span style="color:#6272a4">// Drop victim caches from all pools.
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, p <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> oldPools {
		p.victim = <span style="color:#ff79c6">nil</span>
		p.victimSize = <span style="color:#bd93f9">0</span>
	}

	<span style="color:#6272a4">// Move primary cache to victim cache.
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> _, p <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> allPools {
		p.victim = p.local
		p.victimSize = p.localSize
		p.local = <span style="color:#ff79c6">nil</span>
		p.localSize = <span style="color:#bd93f9">0</span>
	}

	<span style="color:#6272a4">// The pools with non-empty primary caches now have non-empty
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// victim caches and no pools have primary caches.
</span><span style="color:#6272a4"></span>	oldPools, allPools = allPools, <span style="color:#ff79c6">nil</span>
}

</code></pre></div><p>整个功能实现是比较简单的。</p>
<p>1、将oldPools中的victim清空</p>
<p>2、将allPools中的local更新到victim</p>
<p>3、将allPools变为oldPools</p>
<p>对比go1.12的代码更容易看出引入这个victim设计的原因：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#8be9fd;font-style:italic">func</span> <span style="color:#50fa7b">poolCleanup</span>() {
	<span style="color:#6272a4">// This function is called with the world stopped, at the beginning of a garbage collection.
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// It must not allocate and probably should not call any runtime functions.
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// Defensively zero out everything, 2 reasons:
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 1. To prevent false retention of whole Pools.
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">// 2. If GC happens while a goroutine works with l.shared in Put/Get,
</span><span style="color:#6272a4"></span>	<span style="color:#6272a4">//    it will retain whole Pool. So next cycle memory consumption would be doubled.
</span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">for</span> i, p <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> allPools {
		allPools[i] = <span style="color:#ff79c6">nil</span>
		<span style="color:#ff79c6">for</span> i <span style="color:#ff79c6">:=</span> <span style="color:#bd93f9">0</span>; i &lt; <span style="color:#8be9fd;font-style:italic">int</span>(p.localSize); i<span style="color:#ff79c6">++</span> {
			l <span style="color:#ff79c6">:=</span> <span style="color:#50fa7b">indexLocal</span>(p.local, i)
			l.private = <span style="color:#ff79c6">nil</span>
			<span style="color:#ff79c6">for</span> j <span style="color:#ff79c6">:=</span> <span style="color:#ff79c6">range</span> l.shared {
				l.shared[j] = <span style="color:#ff79c6">nil</span>
			}
			l.shared = <span style="color:#ff79c6">nil</span>
		}
		p.local = <span style="color:#ff79c6">nil</span>
		p.localSize = <span style="color:#bd93f9">0</span>
	}
	allPools = []<span style="color:#ff79c6">*</span>Pool{}
}

</code></pre></div><p>通过对比，可以看出其实victim会滞留一些待GC的对象。相当于降低了GC时候清理内存的数量。加倍了缓存对象的生命周期。只有在两次GC之间没有Get的对象，才会被GC。</p>
<h2 id="总结">总结</h2>
<p><code>sync.Pool</code>代码不多。通过阅读官方文档，通读代码。以及源码注释。可以了解<code>sync.Pool</code>的使用方法。通过自己写demo的方式可以验证其用法，以及优势。总结如下：</p>
<p>1、在创建临时对象的时候，使用<code>sync.Pool</code>可以减少GC，从而提升程序性能</p>
<p>2、<code>sync.Pool</code>是协程并发安全的。是通过每一个P分配一个缓存，同一个P打开禁止调度实现的。</p>
<p>3、<code>sync.Pool</code>每次<code>Put</code>和<code>Get</code>会先获取当前缓存的<code>private</code>对象，如果不存在通过<code>shared</code>对象从其他P偷取，如果其他P也没有则通过<code>victim</code>对象获取。</p>
<p>4、运行时如果增加P的数量，缓存会进行重新分配。</p>
<p>5、每一个<code>Pool</code>对象都是内嵌了<code>noCopy</code>，是全局唯一的。<!-- raw HTML omitted -->
7、pool中的数据如果在两个GC周期没有进行<code>Get</code>操作，则会被清除。因此不要对pool中的对象做存在性假设。<!-- raw HTML omitted -->
8、<code>shared</code>对象使用的是无锁队列，这部分代码对于学习无锁队列和dqueue都大有裨益。<!-- raw HTML omitted --></p>
<h1 id="refrence">Refrence</h1>
<!-- raw HTML omitted -->
<ul>
<li>[1] <a href="https://golang.org/pkg/sync/#Pool">sync.Pool包官方文档</a></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>[2] <a href="https://github.com/golang/go/blob/release-branch.go1.13/src/sync/pool.go">sync.Pool pool release-1.13 源代码</a></p>
</li>
<li>
<p>[3]<a href="https://github.com/golang/go/blob/release-branch.go1.13/src/sync/poolqueue.go">sync.Pool poolqueue release-1.13 源代码</a></p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>[4]  <a href="https://en.wikipedia.org/wiki/False_sharing">false sharing wikipedia</a></li>
<li>[5] <a href="https://juejin.im/post/5d4087276fb9a06adb7fbe4a">由浅入深聊聊Golang的sync.Pool</a></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>[6] <a href="https://blog.csdn.net/u011957758/article/details/83018425">关于goroutine的一些小理解</a></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>[7] <a href="https://medium.com/a-journey-with-go/go-understand-the-design-of-sync-pool-2dde3024e277">Go: Understand the Design of Sync.Pool</a></p>
</li>
<li>
<p>[8] <a href="https://juejin.im/post/5d4087276fb9a06adb7fbe4a">由浅入深聊聊Golang的sync.Pool</a></p>
</li>
<li>
<p>[9] <a href="https://zhuanlan.zhihu.com/p/76812714">请问sync.Pool有什么缺点？</a></p>
</li>
<li>
<p>[10] <a href="https://blog.yuantops.com/tech/sync-pool-benchmark/">用Benchmark验证sync.Pool对GC latency的优化效果</a></p>
</li>
<li>
<p>[11] <a href="https://www.cnblogs.com/qcrao-2018/p/12736031.html">深度解密 Go 语言之 sync.Pool</a></p>
</li>
<li>
<p>[12] <a href="https://zhuanlan.zhihu.com/p/110140126">理解Go 1.13中sync.Pool的设计与实现</a></p>
</li>
</ul>


                

                <hr>
                <ul class="pager">
                    
                    
                </ul>

                
<div id="disqus-comment"></div>



            </div>
            
            <div class="
                col-lg-11 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                    
                    
                    
                    
                    

                    

		    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
                </ul>
		<p class="copyright text-muted">
                    Copyright &copy; Mark&#39;s Blog 2020
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>



<script>
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https'){
       bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else{
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>



<script>
    
    var _baId = '4646b61c8b5071a27dbdac7ac69ba9da';

    
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>




</body>
</html>
